--- trunk/math/mathcore/inc/Fit/Chi2FCN.h	2010/12/03 18:09:43	37232
+++ trunk/math/mathcore/inc/Fit/Chi2FCN.h	2011/08/12 10:43:12	40577
@@ -53,16 +53,6 @@
    namespace Fit { 
 
 
-template<class FunType> 
-struct ModelFunctionTrait { 
-   typedef  ::ROOT::Math::IParamMultiFunction ModelFunc;
-};
-template<>      
-struct ModelFunctionTrait<ROOT::Math::IMultiGradFunction>  { 
-   typedef  ::ROOT::Math::IParamMultiGradFunction ModelFunc;
-};
-
-
 
 //___________________________________________________________________________________
 /** 
@@ -80,7 +70,8 @@
    typedef  ::ROOT::Math::BasicFitMethodFunction<FunType> BaseObjFunction; 
    typedef typename  BaseObjFunction::BaseFunction BaseFunction; 
 
-   typedef  typename ModelFunctionTrait<FunType>::ModelFunc IModelFunction;
+   //typedef  typename ::ROOT::Math::ParamFunctionTrait<FunType>::PFType IModelFunction;
+   typedef  ::ROOT::Math::IParamMultiFunction IModelFunction;
    typedef typename BaseObjFunction::Type_t Type_t;
 
    /** 
@@ -138,7 +129,7 @@
       return FitUtil::EvaluateChi2Residual(fFunc, fData, x, i, g); 
    }
 
-   // need to be virtual to be instantited
+   // need to be virtual to be instantiated
    virtual void Gradient(const double *x, double *g) const { 
       // evaluate the chi2 gradient
       FitUtil::EvaluateChi2Gradient(fFunc, fData, x, g, fNEffPoints);
--- trunk/math/mathcore/inc/Math/FitMethodFunction.h	2009/12/10 10:40:21	31763
+++ trunk/math/mathcore/inc/Math/FitMethodFunction.h	2011/08/12 10:43:12	40577
@@ -17,6 +17,10 @@
 #include "Math/IFunction.h"
 #endif
 
+// #ifndef ROOT_Math_IParamFunctionfwd
+// #include "Math/IParamFunctionfwd.h"
+// #endif
+
 namespace ROOT { 
 
    namespace Math { 
@@ -114,9 +118,30 @@
       typedef BasicFitMethodFunction<ROOT::Math::IMultiGradFunction> FitMethodGradFunction;
 
 
+      // useful template definition to use these interface in 
+      // generic programming
+      // (comment them out since they are not used anymore) 
+/*
+      template<class FunType> 
+      struct ParamFunctionTrait { 
+         typedef  IParamMultiFunction PFType;
+      };
+
+      // specialization for the gradient param functions
+      template<>      
+      struct ParamFunctionTrait<ROOT::Math::IMultiGradFunction>  { 
+         typedef  IParamMultiGradFunction PFType;
+      };
+*/
+
+
    } // end namespace Math
 
 } // end namespace ROOT
 
 
+
+
+
+
 #endif /* ROOT_Math_FitMethodFunction */
--- trunk/math/mathcore/inc/Math/IFunctionfwd.h	2008/03/28 13:57:25	22885
+++ trunk/math/mathcore/inc/Math/IFunctionfwd.h	2011/08/12 10:43:12	40577
@@ -18,25 +18,6 @@
 
    namespace Math { 
 
-#ifdef OLD
-      template<class DimensionType> class IBaseFunction; 
-      template<class DimensionType> class IGradientFunction; 
-
-
-      /// tag for multi-dimensional functions
-      struct MultiDim {}; 
-      
-      /// tag for one-dimensional functions
-      struct OneDim {}; 
-
-
-      typedef IBaseFunction<OneDim>        IGenFunction;   
-      typedef IBaseFunction<MultiDim>      IMultiGenFunction; 
-
-      typedef IGradientFunction<OneDim>        IGradFunction; 
-      typedef IGradientFunction<MultiDim>      IMultiGradFunction; 
-#endif
-
       class IBaseFunctionOneDim; 
       class IGradientFunctionOneDim; 
       class IBaseFunctionMultiDim; 
--- trunk/math/mathcore/inc/Math/IParamFunctionfwd.h	2008/03/28 13:57:25	22885
+++ trunk/math/mathcore/inc/Math/IParamFunctionfwd.h	2011/08/12 10:43:12	40577
@@ -21,20 +21,6 @@
 
    namespace Math { 
 
-
-#ifdef OLD
-
-      template<class DimensionType> class IParametricFunction; 
-      template<class DimensionType> class IParametricGradFunction; 
-
-      typedef IParametricFunction<OneDim>        IParamFunction;   
-      typedef IParametricFunction<MultiDim>      IParamMultiFunction; 
-
-      typedef IParametricGradFunction<OneDim>        IParamGradFunction; 
-      typedef IParametricGradFunction<MultiDim>      IParamMultiGradFunction; 
-
-#endif
-
       class IParametricFunctionOneDim; 
       class IParametricGradFunctionOneDim; 
       class IParametricFunctionMultiDim; 
--- trunk/math/minuit/src/TLinearMinimizer.cxx	2010/10/04 14:38:48	36058
+++ trunk/math/minuit/src/TLinearMinimizer.cxx	2011/08/12 10:43:12	40577
@@ -35,7 +35,7 @@
 // they are the derivatives w.r.t the parameters of the model function 
 template<class Func> 
 struct BasisFunction { 
-   BasisFunction(Func & f, int k) : 
+   BasisFunction(const Func & f, int k) : 
       fKPar(k), 
       fFunc(&f) 
    {}
@@ -45,7 +45,7 @@
    }
 
    unsigned int fKPar; // param component
-   Func * fFunc; 
+   const Func * fFunc; 
 };
 
 
@@ -134,12 +134,13 @@
    }
    fObjFunc = chi2func;
 
-   // get model function
-   typedef  Chi2Func::IModelFunction ModelFunc; 
-   const ModelFunc & modfunc =  chi2func->ModelFunction(); 
+   // need to get the gradient parametric model function
+   typedef  ROOT::Math::IParamMultiGradFunction ModelFunc; 
+   const  ModelFunc * modfunc = dynamic_cast<const ModelFunc*>( &(chi2func->ModelFunction()) ); 
+   assert(modfunc != 0);
+
    fDim = chi2func->NDim(); // number of parameters
    fNFree = fDim;
-
    // get the basis functions (derivatives of the modelfunc)
    TObjArray flist; 
    for (unsigned int i = 0; i < fDim; ++i) { 
@@ -147,7 +148,7 @@
       // when creating TF1 (if onother function with same name exists it is 
       // deleted since it is added in function list in gROOT 
       // fix the problem using meaniful names (difficult to re-produce)
-      BasisFunction<const ModelFunc> bf(modfunc,i); 
+      BasisFunction<ModelFunc > bf(*modfunc,i); 
       TUUID u; 
       std::string fname = "_LinearMinimimizer_BasisFunction_" + 
          std::string(u.AsString() );
@@ -160,7 +161,7 @@
 
    // create TLinearFitter (do it now because olny now now the coordinate dimensions)
    if (fFitter) delete fFitter; // reset by deleting previous copy
-   fFitter = new TLinearFitter( static_cast<const ModelFunc::BaseFunc&>(modfunc).NDim() ); 
+   fFitter = new TLinearFitter( static_cast<const ModelFunc::BaseFunc&>(*modfunc).NDim() ); 
 
    fFitter->StoreData(fRobust); //  need a copy of data in case of robust fitting 
 
