diff -ur root-5.34.09.orig/io/hdfs/src/THDFSFile.cxx root-5.34.09/io/hdfs/src/THDFSFile.cxx
--- root-5.34.09.orig/io/hdfs/src/THDFSFile.cxx	2013-06-26 17:05:06.000000000 +0200
+++ root-5.34.09/io/hdfs/src/THDFSFile.cxx	2013-08-31 03:00:10.323742733 +0200
@@ -40,6 +40,7 @@
 
 #include "syslog.h"
 #include "assert.h"
+#include "stdlib.h"
 
 #include "THDFSFile.h"
 #include "TError.h"
@@ -93,8 +94,7 @@
    if (has_authn) {
       UserGroup_t *ugi = gSystem->GetUserInfo(0);
       const char *user = (ugi->fUser).Data();
-      const char * groups[1] = {(ugi->fGroup.Data())};
-      fFS = hdfsConnectAsUser("default", 0, user, groups, 1);
+      fFS = hdfsConnectAsUser("default", 0, user);
       delete ugi;
    } else {
       fFS = hdfsConnect("default", 0);
@@ -167,7 +167,7 @@
    // See documentation for TFile::SysRead().
 
    TRACE("READ")
-   tSize num_read = hdfsPread(fFS, (hdfsFile)fHdfsFH, fSysOffset, buf, len);
+   tSize num_read = hdfsPread((hdfsFS)fFS, (hdfsFile)fHdfsFH, fSysOffset, buf, len);
    fSysOffset += len;
    if (num_read < 0) {
       gSystem->SetErrorStr(strerror(errno));
@@ -192,7 +192,7 @@
          return -1;
       }
       if (fSize == -1) {
-         hdfsFileInfo *info = hdfsGetPathInfo(fFS, fPath);
+         hdfsFileInfo *info = hdfsGetPathInfo((hdfsFS)fFS, fPath);
          if (info != 0) {
             fSize = info->mSize;
             free(info);
@@ -224,7 +224,7 @@
       SysError("THDFSFile", "Unable to allocate memory for path.");
    }
    strlcpy(fPath, file,path_size+1);
-   if ((fHdfsFH = hdfsOpenFile(fFS, fPath, flags, 0, 0, 0)) == 0) {
+   if ((fHdfsFH = hdfsOpenFile((hdfsFS)fFS, fPath, flags, 0, 0, 0)) == 0) {
       SysError("THDFSFile", "Unable to open file %s in HDFS", pathname);
       return -1;
    }
@@ -236,7 +236,7 @@
 {
    // Close the file in HDFS.
 
-   int result = hdfsCloseFile(fFS, (hdfsFile)fHdfsFH);
+   int result = hdfsCloseFile((hdfsFS)fFS, (hdfsFile)fHdfsFH);
    fFS = 0;
    fHdfsFH = 0;
    return result;
@@ -258,7 +258,7 @@
 
    *id = ::Hash(fPath);
 
-   hdfsFileInfo *info = hdfsGetPathInfo(fFS, fPath);
+   hdfsFileInfo *info = hdfsGetPathInfo((hdfsFS)fFS, fPath);
    if (info != 0) {
       fSize = info->mSize;
       *size = fSize;
@@ -306,8 +306,7 @@
    if (has_authn) {
       UserGroup_t *ugi = gSystem->GetUserInfo(0);
       const char *user = (ugi->fUser).Data();
-      const char * groups[1] = {(ugi->fGroup.Data())};
-      fFH = hdfsConnectAsUser("default", 0, user, groups, 1);
+      fFH = hdfsConnectAsUser("default", 0, user);
       delete ugi;
    } else {
       fFH = hdfsConnect("default", 0);
@@ -339,7 +338,7 @@
    }
 
    if (R__HDFS_ALLOW_CHANGES == kTRUE) {
-      return hdfsCreateDirectory(fFH, path);
+      return hdfsCreateDirectory((hdfsFS)fFH, path);
    } else {
       return -1;
    }
@@ -366,14 +365,14 @@
 */
 
    hdfsFileInfo * dir = 0;
-   if ((dir = hdfsGetPathInfo(fFH, path)) == 0) {
+   if ((dir = hdfsGetPathInfo((hdfsFS)fFH, path)) == 0) {
       return 0;
    }
    if (dir->mKind != kObjectKindDirectory) {
       return 0;
    }
 
-   fDirp = (void *)hdfsListDirectory(fFH, path, &fDirEntries);
+   fDirp = (void *)hdfsListDirectory((hdfsFS)fFH, path, &fDirEntries);
    fDirCtr = 0;
 
    fUrlp = new TUrl[fDirEntries];
@@ -449,7 +448,7 @@
       Error("GetPathInfo", "No filesystem handle (should never happen)");
       return 1;
    }
-   hdfsFileInfo *fileInfo = hdfsGetPathInfo(fFH, path);
+   hdfsFileInfo *fileInfo = hdfsGetPathInfo((hdfsFS)fFH, path);
 
    if (fileInfo == 0)
       return 1;
@@ -481,7 +480,7 @@
       return kTRUE;
    }
 
-   if (hdfsExists(fFH, path) == 0)
+   if (hdfsExists((hdfsFS)fFH, path) == 0)
       return kFALSE;
    else
       return kTRUE;
@@ -499,7 +498,7 @@
    }
 
    if (R__HDFS_ALLOW_CHANGES == kTRUE) {
-      return hdfsDelete(fFH, path);
+      return hdfsDelete((hdfsFS)fFH, path, 1);
    } else {
       return -1;
    }
