diff -ur root-6.06.02.orig/graf2d/mathtext/src/fontembedps.cxx root-6.06.02/graf2d/mathtext/src/fontembedps.cxx
--- root-6.06.02.orig/graf2d/mathtext/src/fontembedps.cxx	2016-03-03 10:36:03.000000000 +0100
+++ root-6.06.02/graf2d/mathtext/src/fontembedps.cxx	2016-03-20 14:52:11.268005800 +0100
@@ -30,14 +30,14 @@
 #ifndef LITTLE_ENDIAN
 #define LITTLE_ENDIAN 1
 #endif // LITTLE_ENDIAN
-#include "Byteswap.h"
-#define bswap_16(x)   Rbswap_16((x))
-#define bswap_32(x)   Rbswap_32((x))
 #else // R__BYTESWAP
 #ifdef LITTLE_ENDIAN
 #undef LITTLE_ENDIAN
 #endif // LITTLE_ENDIAN
 #endif // R__BYTESWAP
+#include "Byteswap.h"
+#define bswap_16(x)   Rbswap_16((x))
+#define bswap_32(x)   Rbswap_32((x))
 
 // References:
 //
@@ -236,29 +236,26 @@
       if(magic_number[0] == '\200') {
          // IBM PC format printer font binary
 
-         // FIXME: Maybe the real name can be parsed out of the
-         // file
-         font_name = "";
-
          struct pfb_segment_header_s segment_header;
          size_t offset = 0;
 
-         segment_header.type = 0;
+         // The two char elements of struct
+         // pfb_segment_header_s are most likely aligned to
+         // larger than 1 byte boundaries, so copy all the
+         // elements individually
+         segment_header.always_128 = font_data[offset];
+         segment_header.type = font_data[offset + 1];
+
          while (segment_header.type != TYPE_EOF) {
-            // The two char elements of struct
-            // pfb_segment_header_s are most likely aligned to
-            // larger than 1 byte boundaries, so copy all the
-            // elements individually
-            segment_header.always_128 = font_data[offset];
-            segment_header.type = font_data[offset + 1];
             memcpy(&segment_header.length, &font_data[offset + 2],
                    sizeof(unsigned int));
             offset += sizeof(unsigned int) + 2;
-#ifdef LITTLE_ENDIAN
+#ifndef LITTLE_ENDIAN
             segment_header.length =
             bswap_32(segment_header.length);
 #endif // LITTLE_ENDIAN
             char *buffer = new char[segment_header.length];
+            char *fname;
 
             memcpy(buffer, &font_data[offset],
                    segment_header.length);
@@ -278,6 +275,26 @@
                      buffer[segment_header.length - 1] = '\n';
                   }
                   ret.append(buffer, segment_header.length);
+
+                  fname = (char*)memmem(buffer, segment_header.length,
+                                        "/FontName", 9);
+                  if (fname) {
+                     fname += 9;
+                     while (fname < buffer + segment_header.length &&
+                            isspace(*fname)) {
+                        fname++;
+                     }
+                     if (fname < buffer + segment_header.length &&
+                         *fname == '/') {
+                        fname++;
+                     }
+                     int len = 0;
+                     while (fname + len < buffer + segment_header.length &&
+                            isgraph(*(fname + len))) {
+                        len++;
+                     }
+                     font_name.assign(fname, len);
+                  }
                   break;
                case TYPE_BINARY:
                   append_asciihex(
@@ -289,6 +306,9 @@
             }
 
             delete [] buffer;
+
+            segment_header.always_128 = font_data[offset];
+            segment_header.type = font_data[offset + 1];
          }
 
          return ret;
