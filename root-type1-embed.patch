diff -ur root-5.34.32.orig/graf2d/mathtext/src/fontembedps.cxx root-5.34.32/graf2d/mathtext/src/fontembedps.cxx
--- root-5.34.32.orig/graf2d/mathtext/src/fontembedps.cxx	2015-06-23 17:56:20.000000000 +0200
+++ root-5.34.32/graf2d/mathtext/src/fontembedps.cxx	2015-07-02 09:10:36.740969892 +0200
@@ -30,14 +30,14 @@
 #ifndef LITTLE_ENDIAN
 #define LITTLE_ENDIAN 1
 #endif // LITTLE_ENDIAN
-#include "Byteswap.h"
-#define bswap_16(x)   Rbswap_16((x))
-#define bswap_32(x)   Rbswap_32((x))
 #else // R__BYTESWAP
 #ifdef LITTLE_ENDIAN
 #undef LITTLE_ENDIAN
 #endif // LITTLE_ENDIAN
 #endif // R__BYTESWAP
+#include "Byteswap.h"
+#define bswap_16(x)   Rbswap_16((x))
+#define bswap_32(x)   Rbswap_32((x))
 
 // References:
 //
@@ -225,27 +225,25 @@
       if(magic_number[0] == '\200') {
          // IBM PC format printer font binary
 
-         // FIXME: Maybe the real name can be parsed out of the
-         // file
-         font_name = "";
-
          struct pfb_segment_header_s segment_header;
-         size_t offset = 2;
+         size_t offset = 0;
 
          // The two char elements of struct pfb_segment_header_s
          // are most likely aligned to larger than 1 byte
          // boundaries, so copy all the elements individually
          segment_header.always_128 = font_data[offset];
          segment_header.type = font_data[offset + 1];
-         memcpy(&segment_header.length, &font_data[offset + 2],
-                sizeof(unsigned int));
-         offset += sizeof(unsigned int) + 2;
+
          while (segment_header.type != TYPE_EOF) {
-#ifdef LITTLE_ENDIAN
+            memcpy(&segment_header.length, &font_data[offset + 2],
+                   sizeof(unsigned int));
+            offset += sizeof(unsigned int) + 2;
+#ifndef LITTLE_ENDIAN
             segment_header.length =
             bswap_32(segment_header.length);
 #endif // LITTLE_ENDIAN
             char *buffer = new char[segment_header.length];
+            char *fname;
 
             memcpy(buffer, &font_data[offset],
                    segment_header.length);
@@ -265,6 +263,26 @@
                      buffer[segment_header.length - 1] = '\n';
                   }
                   ret.append(buffer, segment_header.length);
+
+                  fname = (char*)memmem(buffer, segment_header.length,
+                                        "/FontName", 9);
+                  if (fname) {
+                     fname += 9;
+                     while (fname < buffer + segment_header.length &&
+                            isspace(*fname)) {
+                        fname++;
+                     }
+                     if (fname < buffer + segment_header.length &&
+                         *fname == '/') {
+                        fname++;
+                     }
+                     int len = 0;
+                     while (fname + len < buffer + segment_header.length &&
+                            isgraph(*(fname + len))) {
+                        len++;
+                     }
+                     font_name.assign(fname, len);
+                  }
                   break;
                case TYPE_BINARY:
                   append_asciihex(
@@ -276,6 +294,9 @@
             }
 
             delete [] buffer;
+
+            segment_header.always_128 = font_data[offset];
+            segment_header.type = font_data[offset + 1];
          }
 
          return ret;
